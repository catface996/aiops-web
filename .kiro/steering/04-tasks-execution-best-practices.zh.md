---
inclusion: always
---

# 任务执行阶段最佳实践

## 阶段目标

按照任务列表逐个执行任务，将设计转化为可运行的代码，确保每个任务完成后项目处于健康状态。

## 为什么任务执行阶段如此重要

任务执行是将设计变为现实的关键阶段。良好的执行实践可以：
- 确保项目持续健康状态
- 及早发现和解决问题
- 提高代码质量和可维护性
- 支持团队协作开发
- 降低集成和部署风险

**核心原则（不可违反）**：
1. 每个任务完成后，项目必须成功构建
2. 必须遵循执行工作流：实现 → 测试 → 验证 → 报告 → 提交 → 推送
3. Git 推送必须使用 `--no-verify` 标志以绕过预提交钩子

## 任务执行工作流（严格按此顺序执行）

### 步骤 1：理解任务

在开始执行任务之前，充分理解任务需求。

**关键活动**：
- 仔细阅读任务描述和验收标准
- 理解任务目标和预期输出
- 确认前置条件已满足
- 识别可能的技术难点

**输出**：清楚理解需要做什么

---

### 步骤 2：实现功能

根据任务描述实现功能。

**实现原则**：

#### 1. 保持项目持续可构建

**关键要求**：每个任务完成后，整个项目必须能够成功构建。

**为什么重要**：
- 项目始终处于可运行状态
- 及时发现集成问题
- 支持持续集成和持续交付
- 降低后期集成风险

**如何实现**：
- 完成任务后立即运行构建命令
- 进入下一个任务前确保构建成功
- 遇到构建失败时立即修复

#### 2. 渐进式开发

**核心思想**：在多模块或多组件项目中，采用渐进式开发策略，避免声明尚未创建的模块或组件。

**基本原则**：
- 只声明已创建的组件
- 创建组件时同步更新配置
- 多层级结构同样适用此原则

**为什么重要**：
- 避免构建错误
- 保持配置与实际结构同步
- 支持增量开发

#### 3. 遵循代码质量标准

**编码标准**：
- 遵循项目统一的代码风格
- 使用有意义的变量和方法命名
- 添加必要的注释和文档

**错误处理**：
- 实现统一的异常处理机制
- 提供清晰的错误消息
- 避免异常消息泄露敏感数据

**输出**：已实现的代码文件

---

### 步骤 3：编写和运行测试（不可违反）

**关键**：测试必须在验证之前编写和执行。

**测试要求**：
- 为核心业务逻辑编写单元测试（如果任务要求）
- 编写基于属性的测试，最少 100 次迭代（如适用）
- 确保测试覆盖率达到合理水平
- 集成测试验证模块协作

**测试执行顺序**：
```bash
# 1. 运行所有测试
npm test

# 2. 检查覆盖率（如需要）
npm run test:coverage

# 3. 运行类型检查
npm run type-check

# 4. 运行代码检查
npm run lint
```

**测试成功标准**：
- ✅ 所有测试通过（100% 通过率）
- ✅ 无测试失败或错误
- ✅ 覆盖率符合项目标准（如已定义）
- ✅ 无 TypeScript 错误
- ✅ 无代码检查错误

**如果测试失败**：
1. 查看失败消息和堆栈跟踪
2. 修复实现问题
3. 重新运行测试直到全部通过（最多 5 次迭代）
4. 如果 5 次迭代后仍然失败，记录问题并咨询用户
5. **绝不在测试通过前进入验证阶段**

**测试输出格式**：
```
✅ 单元测试：15/15 通过
✅ 属性测试：3/3 通过（每个 100 次迭代）
✅ 集成测试：5/5 通过
✅ 类型检查：通过
✅ 代码检查：通过
```

**输出**：所有测试通过并记录结果

---

### 步骤 4：验证任务

测试通过后，根据验收标准验证任务。

**验证优先级**：

#### 1. 运行时验证（最高优先级）

**规则**：可以通过实际运行应用程序验证的功能，必须通过运行应用程序来验证。

**适用场景**：
- 配置验证（多环境、功能开关等）
- API 端点功能验证
- 日志输出格式验证
- 异常处理验证
- 集成功能验证
- 外部服务连接验证
- UI 组件渲染和交互
- 认证和授权流程

**验证方法**：
```bash
# 1. 启动应用程序
npm run dev

# 2. 访问相关功能
# - 在浏览器中打开 http://localhost:5173
# - 导航到相关页面
# - 测试用户交互
# - 验证 API 响应
# - 检查控制台错误

# 3. 记录结果
# - 截图关键功能（如有 UI 变更）
# - 记录 API 响应（如有后端变更）
# - 注意任何意外行为
```

**验证清单**：
- [ ] 应用程序启动无错误
- [ ] 相关页面/组件正确渲染
- [ ] 用户交互按预期工作
- [ ] API 调用返回正确响应
- [ ] 无控制台错误或警告
- [ ] 性能可接受（无明显延迟）

**输出**：运行时验证结果已记录

#### 2. 构建验证（第二优先级）

**规则**：对于无法通过运行时验证的结构性需求，通过项目构建进行验证。

**适用场景**：
- 模块/组件结构验证
- 依赖关系验证
- 构建配置验证
- 代码语法正确性验证
- TypeScript 类型检查
- 导入/导出一致性

**验证方法**：
```bash
# 1. 清理之前的构建
rm -rf dist/

# 2. 运行生产构建
npm run build

# 3. 检查构建输出
ls -la dist/

# 4. 验证构建产物
# - 检查文件大小是否合理
# - 验证所有预期文件都已生成
# - 检查构建日志中的任何警告
```

**构建成功标准**：
- ✅ 构建完成无错误
- ✅ 无 TypeScript 编译错误
- ✅ 无模块解析错误
- ✅ 所有预期输出文件已生成
- ✅ 构建警告已处理或记录

**如果构建失败**：
1. 仔细阅读错误消息
2. 检查导入路径和模块名称
3. 验证 TypeScript 类型正确
4. 确保所有依赖已安装
5. 修复问题并重新构建
6. **绝不在构建失败的情况下继续**

**输出**：构建验证结果已记录

#### 3. 静态检查（最后手段）

仅当无法通过上述两种方法验证时，才使用静态文件检查。

**适用场景**：
- 文件存在性检查
- 配置文件内容检查
- 目录结构检查

### 步骤 4：任务完成确认

确认任务完全完成，满足所有验收标准。

**检查点**：
- 所有验收标准通过
- 项目可以成功构建
- 代码质量符合标准
- 相关文档已更新（如需要）

### 步骤 5：需求和设计一致性检查

**关键**：任务验证通过后，必须进行需求和设计一致性检查，确保实现符合原始意图。

**为什么重要**：
- 任务可能通过验收标准但偏离需求意图
- 实现可能违反设计的架构原则
- 及早发现偏差，避免积累技术债务
- 确保整体解决方案的一致性和完整性

**检查维度**：

#### 1. 需求一致性检查

验证任务实现是否真正满足相应需求。

**检查点**：
- [ ] 任务相关的需求是什么？（检查任务中的 `_Requirements:_` 标记）
- [ ] 实现是否完全覆盖需求的所有验收标准？
- [ ] 实现是否准确理解需求意图？
- [ ] 是否存在超出需求范围的实现（过度设计）？
- [ ] 是否有遗漏的需求点？

**验证方法**：
- 打开需求文档，找到对应的需求项
- 检查每个需求验收标准
- 确认实现满足每个验收标准
- 如果存在偏差，记录原因并评估影响

**输出**：验证结果已记录

---

#### 2. 设计一致性检查

验证任务实现是否遵循设计文档中的架构和技术方案。

**检查点**：
- [ ] 实现是否遵循设计文档中的架构模式？
- [ ] 模块划分和职责边界是否符合设计？
- [ ] 接口定义是否与设计一致？
- [ ] 数据模型是否符合设计规范？
- [ ] 技术选型是否与设计一致？
- [ ] 是否遵循设计中的非功能性需求（性能、安全等）？

**验证方法**：
- 打开设计文档，找到相关设计章节
- 与设计中的架构图、模块划分、接口定义进行对比
- 确认实现符合设计规范
- 如果存在偏差，评估是否有合理原因

#### 3. 偏差处理

如果实现偏离需求或设计：

**轻微偏差**（不影响核心功能和架构）：
- 记录偏差原因和影响
- 评估是否需要调整
- 如需调整，创建后续任务

**重大偏差**（影响核心功能或架构）：
- 立即停止后续任务
- 与用户沟通偏差情况
- 确定是纠正实现还是更新需求/设计
- 纠正后重新验证

**合理偏差**（有充分理由的改进）：
- 记录偏差原因和好处
- 更新设计文档（如需要）
- 与用户确认变更
- 评估对后续任务的影响

#### 4. 自检提示

使用以下提示进行自检：

> "请检查刚完成的任务实现是否满足对应需求（需求编号：X.X），是否遵循设计文档中的架构和技术方案。如果存在偏差，请说明原因。"

**检查流程**：
1. 找到任务相关的需求编号
2. 打开需求文档，定位对应需求
3. 检查每个需求验收标准是否满足
4. 打开设计文档，找到相关设计章节
5. 检查实现是否符合设计规范
6. 记录检查结果和发现的问题

**输出**：一致性检查结果

---

### 步骤 6：生成验证报告

**必需**：验证通过后，必须生成结构化的验证报告。

**报告格式**（使用此确切结构）：

```markdown
## 任务验证报告

**任务 ID**：[来自 tasks.md 的任务 ID]
**任务描述**：[简要描述]
**验证日期**：[当前日期]

### 实现摘要
- 创建/修改的文件：[列出文件]
- 关键变更：[简要总结]

### 测试结果
- ✅ 单元测试：[X/Y 通过]
- ✅ 属性测试：[X/Y 通过]
- ✅ 集成测试：[X/Y 通过]
- ✅ 构建状态：成功

### 验收标准验证
- [ ] AC1：[描述] - ✅ 通过 / ❌ 失败
- [ ] AC2：[描述] - ✅ 通过 / ❌ 失败
- [ ] AC3：[描述] - ✅ 通过 / ❌ 失败

### 需求一致性
- 相关需求：[需求 ID]
- 一致性状态：✅ 一致 / ⚠️ 轻微偏差 / ❌ 重大偏差
- 备注：[任何偏差或说明]

### 设计一致性
- 架构合规性：✅ 是 / ❌ 否
- 设计模式合规性：✅ 是 / ❌ 否
- 备注：[任何偏差或说明]

### 验证状态
**总体**：✅ 通过 / ❌ 失败

### 后续步骤
[接下来需要做什么，如果有的话]
```

**报告位置**：
- 在聊天中输出报告供用户审查
- 如果请求，可选保存到 `.kiro/reports/task-[TaskID]-verification.md`

**输出**：验证报告已生成并呈现

---

### 步骤 7：提交变更

**关键**：仅在验证报告显示通过状态后才提交。

**提交消息格式**（严格遵循）：

```
[TaskID] 实现内容的简要描述

- 实现：[关键功能]
- 文件：[主要变更文件]
- 测试：[测试状态]
- 验证：[验证状态]

相关：[需求 ID（如适用）]
```

**提交命令**：
```bash
git add .
git commit -m "[TaskID] 你的提交消息"
```

**示例**：
- ✅ 正确：`git commit -m "T001 实现用户登录表单\n\n- 实现：带验证的登录表单\n- 文件：src/pages/Login/index.tsx\n- 测试：5/5 通过\n- 验证：所有 AC 通过"`
- ❌ 错误：`git commit -m "更新代码"`（太模糊，缺少任务 ID）
- ❌ 错误：`git commit -m "修复 bug"`（无上下文，缺少任务 ID）

**输出**：变更已提交到本地仓库

---

### 步骤 8：推送到远程

**绝对必需**：推送时必须使用 `--no-verify` 标志。

**推送命令**（完全按所示）：
```bash
git push origin [分支名] --no-verify
```

**为什么需要 `--no-verify`**：
- 绕过可能阻止自动化工作流的预推送钩子
- 确保 CI/CD 管道中的一致行为
- 防止阻止执行的交互式提示

**示例**：
```bash
# ✅ 正确
git push origin feature/user-login --no-verify
git push origin main --no-verify

# ❌ 错误 - 缺少 --no-verify 标志
git push origin feature/user-login
git push
```

**如果推送失败**：
1. 检查网络连接
2. 验证分支名称正确
3. 确保有推送权限
4. 如需要，拉取最新变更：`git pull origin [分支名] --rebase`
5. 使用 `--no-verify` 重试推送

**输出**：变更已推送到远程仓库

---

### 工作流总结

**强制执行顺序**（不可违反）：

```
┌─────────────────────────────────────────────────────────────┐
│ 步骤 1：理解任务                                            │
│ 输出：清楚理解需求                                          │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 2：实现功能                                            │
│ 输出：代码文件已创建/修改                                   │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 3：编写和运行测试（不可违反）                          │
│ ⚠️  门槛：所有测试必须通过才能继续                         │
│ 输出：所有测试通过并记录结果                                │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 4：验证任务                                            │
│ 优先级：运行时 > 构建 > 静态                                │
│ 输出：验证结果已记录                                        │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 5：需求和设计一致性检查                                │
│ ⚠️  门槛：重大偏差必须解决                                 │
│ 输出：一致性检查结果                                        │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 6：生成验证报告                                        │
│ ⚠️  门槛：报告必须显示通过状态                             │
│ 输出：结构化验证报告                                        │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 7：提交变更                                            │
│ 格式：[TaskID] 描述 + 详情                                  │
│ 输出：变更已提交到本地仓库                                  │
└────────────────────────┬────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 8：推送到远程（强制 --no-verify）                     │
│ 命令：git push origin [分支] --no-verify                   │
│ 输出：变更已推送到远程仓库                                  │
└─────────────────────────────────────────────────────────────┘
```

**绝对禁止**：
- ❌ 跳过工作流中的任何步骤
- ❌ 更改步骤顺序
- ❌ 在测试失败的情况下继续
- ❌ 没有验证报告就提交
- ❌ 推送时不使用 `--no-verify` 标志
- ❌ 在验证失败的情况下标记任务完成

## 渐进式开发实施步骤

### 1. 确认当前状态
检查配置文件仅包含已创建的组件

### 2. 创建新组件
创建组件目录和必要的配置文件

### 3. 更新配置
在相关配置文件中添加新组件声明

### 4. 验证构建
运行项目的构建命令以确保构建成功

## 常见问题和缓解措施

### 问题 1：构建失败

**表现**：执行构建命令后出现错误，项目无法成功构建。

**常见原因**：
- 组件声明与实际结构不一致
- 依赖关系配置错误
- 语言/框架版本不兼容
- 代码语法错误
- 缺少导入或导出
- TypeScript 类型错误

**缓解步骤**（按顺序执行）：
1. 仔细阅读错误消息 - 它通常指向确切的问题
2. 检查组件声明是否与实际文件结构匹配
3. 验证所有导入使用正确的路径（相对路径 vs 绝对路径）
4. 确认依赖版本兼容
5. 运行 `npm run type-check` 隔离 TypeScript 错误
6. 查看构建日志以定位具体问题
7. 如果 3 次尝试后仍然失败，记录错误并咨询用户

**错误解决示例**：
```
❌ 错误：Cannot find module './components/UserForm'
✅ 修复：检查文件是否存在于正确路径，验证导出语句
```

---

### 问题 2：测试失败

**表现**：测试执行期间失败，阻止进入验证阶段。

**常见原因**：
- 实现不符合测试预期
- 测试设置/清理问题
- 异步时序问题
- Mock/stub 配置错误
- 环境特定问题

**缓解步骤**：
1. 阅读测试失败消息和堆栈跟踪
2. 识别哪些测试失败
3. 审查测试预期 vs 实际实现
4. 检查测试数据和固件
5. 验证异步操作是否正确等待
6. 单独运行失败的测试：`npm test -- -t "测试名称"`
7. 修复实现或测试（以不正确的为准）
8. 重新运行所有测试以确保无回归

**绝不**：
- ❌ 跳过测试以"取得进展"
- ❌ 注释掉失败的测试
- ❌ 在测试失败的情况下继续

---

### 问题 3：运行时错误

**表现**：构建成功但运行时出现错误。

**常见原因**：
- 配置文件格式错误
- 外部服务连接配置错误
- 端口被占用
- 资源文件缺失
- 环境变量未设置
- API 端点配置错误

**缓解步骤**：
1. 检查浏览器控制台的错误消息
2. 验证配置文件格式和内容
3. 确认环境变量设置正确
4. 检查外部服务连接配置
5. 验证端口未被占用：`lsof -i :5173`
6. 确保资源文件存在于正确位置
7. 独立测试 API 端点（例如，使用 curl 或 Postman）

**调试命令**：
```bash
# 检查端口是否被使用
lsof -i :5173

# 查看环境变量
printenv | grep VITE_

# 测试 API 端点
curl http://localhost:8080/api/v1/health
```

---

### 问题 4：集成问题

**表现**：单个组件正常，但组件协作有问题。

**常见原因**：
- 组件接口不一致
- 数据格式不兼容
- 边界和职责划分不清
- Props/事件未正确传递
- 状态管理问题

**缓解步骤**：
1. 验证组件接口一致性（props、事件、返回类型）
2. 检查组件之间的数据格式兼容性
3. 审查组件边界和职责
4. 添加 console.log 跟踪数据流
5. 编写集成测试验证协作
6. 使用 React DevTools 检查组件树和 props

---

### 问题 5：验证标准不清楚

**表现**：不确定如何验证任务完成。

**缓解步骤**：
1. 审查 tasks.md 中任务的验收标准
2. 检查 requirements.md 中的相关需求
3. 根据优先级选择验证方法：
   - **首先**：可以通过运行应用程序验证吗？→ 运行时验证
   - **其次**：是结构性变更吗？→ 构建验证
   - **最后**：以上都不是？→ 静态文件检查
4. 如果仍不确定，询问用户："我应该如何验证 [特定功能] 正常工作？"

---

### 问题 6：Git 推送失败

**表现**：推送命令失败或被阻止。

**常见原因**：
- 网络连接问题
- 认证问题
- 分支保护规则
- 预推送钩子阻止（如果未使用 `--no-verify`）
- 分支分歧

**缓解步骤**：
1. 验证你正在使用 `--no-verify` 标志
2. 检查网络连接
3. 验证分支名称正确
4. 确保有推送权限
5. 如果分支分歧，拉取并变基：
   ```bash
   git pull origin [分支名] --rebase
   git push origin [分支名] --no-verify
   ```
6. 如果认证失败，检查凭据/令牌

**常见推送错误**：
```bash
# ❌ 错误：pre-push hook failed
# ✅ 修复：使用 --no-verify 标志

# ❌ 错误：Updates were rejected (non-fast-forward)
# ✅ 修复：git pull --rebase 然后再次推送

# ❌ 错误：Permission denied
# ✅ 修复：检查仓库访问权限
```

---

### 问题 7：一致性检查失败

**表现**：实现偏离需求或设计。

**偏差类型和行动**：

**轻微偏差**（不影响核心功能）：
- 记录偏差原因和影响
- 评估是否需要调整
- 如需调整，创建后续任务
- 继续当前任务

**重大偏差**（影响核心功能或架构）：
- **立即停止** - 不要继续
- 清楚记录偏差
- 与用户沟通："实现偏离 [需求/设计]，因为 [原因]。我应该：A) 纠正实现，B) 更新需求/设计，C) 其他？"
- 等待用户决定
- 纠正后重新验证

**合理改进**（有充分理由的偏差）：
- 记录偏差原因和好处
- 如需要更新设计文档
- 与用户确认："我通过 [变更] 改进了 [方面]，因为 [原因]。这偏离了原始设计但提供了 [好处]。继续吗？"
- 评估对后续任务的影响

## 任务完成清单

**关键**：在标记任务完成之前，确认以下所有项目：

### 阶段 1：实现检查
- [ ] 已充分理解任务需求和验收标准
- [ ] 代码已实现到正确位置，遵循项目结构
- [ ] 相关配置文件已更新
- [ ] 组件声明与实际目录结构一致
- [ ] 依赖关系配置正确
- [ ] 代码符合质量标准（编码标准、错误处理）

### 阶段 2：测试检查（不可违反）
- [ ] **已为核心业务逻辑编写单元测试**
- [ ] **已编写基于属性的测试，≥100 次迭代（如适用）**
- [ ] **所有测试已执行并通过**
- [ ] **测试覆盖率符合项目标准**
- [ ] **无测试失败或错误**

### 阶段 3：验证检查
- [ ] **项目可以成功构建（强制）**
- [ ] **无构建错误或警告**
- [ ] **如果功能可以运行时验证，已通过运行应用程序验证**
- [ ] **如果是结构性变更，已通过构建验证**
- [ ] **所有验收标准通过**

### 阶段 4：一致性检查（关键）
- [ ] **已找到任务相关的需求编号**
- [ ] **已对照需求文档检查，确认实现满足所有需求验收标准**
- [ ] **已对照设计文档检查，确认实现遵循架构和技术方案**
- [ ] **如果存在偏差，已记录原因并评估影响**
- [ ] **重大偏差已与用户沟通并确认**

### 阶段 5：文档检查
- [ ] **已生成验证报告，状态为通过**
- [ ] **报告包含所有必需部分（实现、测试、AC、一致性）**
- [ ] 相关文档已更新（如需要）

### 阶段 6：版本控制检查（强制）
- [ ] **已使用包含任务 ID 的结构化提交消息提交变更**
- [ ] **提交消息遵循格式：[TaskID] 描述 + 详情**
- [ ] **变更已推送到远程仓库**
- [ ] **推送命令使用了 `--no-verify` 标志**
- [ ] **推送成功完成**

## 关键好处

遵循任务执行阶段最佳实践可以：

- ✅ 确保项目持续健康状态
- ✅ 及早发现和解决问题
- ✅ 提高代码质量和可维护性
- ✅ 支持团队协作开发
- ✅ 降低集成和部署风险
- ✅ 促进持续集成和自动化测试
- ✅ **确保实现与需求和设计一致**
- ✅ **避免积累技术债务和架构偏差**
- ✅ **通过结构化报告维护清晰的审计跟踪**
- ✅ **实现可靠的版本控制和部署**

---

## 三大铁律（不可违反）

**铁律 1**：每个任务完成后，项目必须成功构建
- 没有例外
- 立即修复构建错误
- 绝不在构建失败的情况下进入下一个任务

**铁律 2**：任务验证通过后，必须检查与需求和设计的一致性
- 将实现与需求文档对比
- 验证架构符合设计文档
- 记录任何偏差并提供理由

**铁律 3**：必须遵循完整工作流：实现 → 测试 → 验证 → 报告 → 提交 → 推送
- 绝不跳过测试阶段
- 绝不跳过验证报告
- 绝不跳过版本控制步骤
- 推送时始终使用 `--no-verify` 标志

---

## 快速参考：命令清单

**对于每个任务，按顺序执行这些命令**：

```bash
# 1. 实现后
npm run build              # 验证构建成功

# 2. 运行测试
npm test                   # 所有测试必须通过
npm run test:coverage      # 检查覆盖率

# 3. 运行时验证（如适用）
npm run dev                # 启动开发服务器并手动测试

# 4. 验证报告显示通过后
git add .
git commit -m "[TaskID] 描述\n\n- 实现：...\n- 文件：...\n- 测试：X/Y 通过\n- 验证：所有 AC 通过"

# 5. 推送到远程（必须使用 --no-verify）
git push origin [分支名] --no-verify
```

**绝不忘记推送时的 `--no-verify` 标志！**

---

## 示例：好的 vs 坏的任务执行

### 示例 1：完整的任务执行（✅ 正确）

```
任务：T001 - 实现用户登录表单

1. ✅ 从 requirements.md 理解需求
2. ✅ 在 src/pages/Login/ 实现 LoginForm 组件
3. ✅ 编写 8 个单元测试，全部通过
4. ✅ 运行 npm run build - 成功
5. ✅ 启动开发服务器，手动测试登录流程 - 正常工作
6. ✅ 对照需求检查 - 所有 AC 满足
7. ✅ 生成验证报告 - 通过状态
8. ✅ 提交："T001 实现用户登录表单..."
9. ✅ 推送：git push origin feature/login --no-verify

结果：任务完成，准备进入下一个任务
```

---

### 示例 2：不完整的任务执行（❌ 错误）

```
任务：T001 - 实现用户登录表单

1. ✅ 实现 LoginForm 组件
2. ❌ 跳过编写测试（认为是可选的）
3. ❌ 没有运行构建（假设会正常工作）
4. ❌ 没有手动验证（没时间）
5. ❌ 没有检查需求一致性
6. ❌ 没有生成验证报告
7. ❌ 提交："更新代码"（模糊消息，无任务 ID）
8. ❌ 推送：git push（忘记 --no-verify 标志）

结果：任务不完整，可能有隐藏的 bug，审计跟踪差
```

---

### 示例 3：处理测试失败（✅ 正确）

```
任务：T002 - 添加密码验证

1. ✅ 实现验证逻辑
2. ✅ 编写测试
3. ❌ 测试失败：3/5 通过
4. ✅ 仔细阅读错误消息
5. ✅ 修复验证逻辑 bug
6. ✅ 重新运行测试：5/5 通过
7. ✅ 继续验证
8. ✅ 生成报告显示测试修复
9. ✅ 使用 --no-verify 提交并推送

结果：测试及早发现 bug，在部署前修复
```

---

### 示例 4：处理测试失败（❌ 错误）

```
任务：T002 - 添加密码验证

1. ✅ 实现验证逻辑
2. ✅ 编写测试
3. ❌ 测试失败：3/5 通过
4. ❌ 注释掉失败的测试
5. ❌ 继续"通过"的测试
6. ❌ 生成报告声称所有测试通过
7. ❌ 提交有问题的代码
8. ❌ 推送到远程

结果：bug 发布到生产环境，积累技术债务
```

---

### 示例 5：验证报告（✅ 正确格式）

```markdown
## 任务验证报告

**任务 ID**：T003
**任务描述**：实现会话超时处理
**验证日期**：2025-11-29

### 实现摘要
- 创建/修改的文件：
  - src/contexts/AuthContext/index.tsx
  - src/utils/session.ts
  - src/hooks/useSessionTimeout.ts
- 关键变更：添加 30 分钟不活动后自动登出

### 测试结果
- ✅ 单元测试：12/12 通过
- ✅ 属性测试：2/2 通过（每个 100 次迭代）
- ✅ 集成测试：3/3 通过
- ✅ 构建状态：成功

### 验收标准验证
- [x] AC1：30 分钟不活动后用户登出 - ✅ 通过
- [x] AC2：超时前 5 分钟显示警告 - ✅ 通过
- [x] AC3：用户可以延长会话 - ✅ 通过

### 需求一致性
- 相关需求：FR-004（会话管理）
- 一致性状态：✅ 一致
- 备注：实现符合所有需求标准

### 设计一致性
- 架构合规性：✅ 是（按设计使用 Context 模式）
- 设计模式合规性：✅ 是（遵循会话管理设计）
- 备注：无偏离设计文档

### 验证状态
**总体**：✅ 通过

### 后续步骤
准备进入 T004 - 实现记住我功能
```

---

### 示例 6：提交消息（✅ 正确格式）

```bash
git commit -m "T003 实现会话超时处理

- 实现：30 分钟不活动后自动登出
- 文件：AuthContext、session.ts、useSessionTimeout hook
- 测试：17/17 通过（12 单元 + 2 属性 + 3 集成）
- 验证：所有 AC 通过，运行时测试

相关：FR-004"
```

---

### 示例 7：提交消息（❌ 错误格式）

```bash
# ❌ 太模糊，无任务 ID
git commit -m "更新代码"

# ❌ 无详情，缺少测试信息
git commit -m "T003 会话超时"

# ❌ 无任务 ID，不清楚变更了什么
git commit -m "修复认证中的 bug"

# ❌ 仅实现细节，无验证信息
git commit -m "添加带 30 分钟计时器的 useSessionTimeout hook"
```

---

## 要避免的反模式

### 反模式 1："稍后再测试"
**问题**：跳过测试以加快速度
**为什么不好**：bug 积累，后期更难调试
**正确方法**：实现后立即编写和运行测试

### 反模式 2："构建可能正常"
**问题**：不运行构建命令
**为什么不好**：集成问题发现太晚
**正确方法**：每个任务完成后运行构建

### 反模式 3："差不多就行"
**问题**：有小问题就标记任务完成
**为什么不好**：技术债务积累
**正确方法**：标记完成前修复所有问题

### 反模式 4："快速提交"
**问题**：模糊的提交消息，无任务 ID
**为什么不好**：审计跟踪差，难以跟踪变更
**正确方法**：使用结构化提交消息格式

### 反模式 5："直接推送"
**问题**：忘记 `--no-verify` 标志
**为什么不好**：预推送钩子可能阻止自动化工作流
**正确方法**：始终使用 `--no-verify` 标志

### 反模式 6："我知道是什么意思"
**问题**：不检查需求/设计文档
**为什么不好**：实现可能偏离意图
**正确方法**：始终对照需求和设计验证

### 反模式 7："不需要报告"
**问题**：跳过验证报告
**为什么不好**：没有验证内容的文档
**正确方法**：始终生成结构化验证报告

---

## 成功模式

### 模式 1：测试驱动思维
- 实现后立即编写测试
- 开发期间频繁运行测试
- 立即修复失败，绝不推迟

### 模式 2：持续验证
- 每次重大变更后构建
- 频繁测试运行时行为
- 在问题容易修复时及早发现

### 模式 3：文档纪律
- 为每个任务生成验证报告
- 使用结构化提交消息
- 维护清晰的审计跟踪

### 模式 4：一致性检查
- 始终对照需求比较
- 验证设计合规性
- 记录任何偏差并提供理由

### 模式 5：自动化友好
- 推送时始终使用 `--no-verify`
- 遵循一致的命令模式
- 启用 CI/CD 集成

---

## 最终提醒

**开始任何任务之前**：
- [ ] 阅读并理解完整工作流
- [ ] 打开 requirements.md 和 design.md 以供参考
- [ ] 准备按顺序遵循所有 8 个步骤

**任务执行期间**：
- [ ] 绝不跳过步骤
- [ ] 绝不在测试失败的情况下继续
- [ ] 绝不在没有验证报告的情况下提交
- [ ] 绝不在没有 `--no-verify` 的情况下推送

**任务完成后**：
- [ ] 验证报告显示通过
- [ ] 所有测试通过
- [ ] 构建成功
- [ ] 使用结构化消息提交变更
- [ ] 使用 `--no-verify` 推送变更到远程
- [ ] 准备开始下一个任务

**记住**：质量优于速度。正确执行的任务优于仓促完成的不完整任务。
